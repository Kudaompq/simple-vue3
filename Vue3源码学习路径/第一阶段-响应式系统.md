# 第一阶段：基础响应式系统

## 🎯 阶段目标
深入理解Vue 3响应式系统的核心原理，掌握Proxy、依赖收集、派发更新等关键概念。

## 🔍 核心问题

### 问题1：什么是响应式？为什么需要响应式？
**学习重点：**
- 理解响应式编程的概念
- 对比Vue 2和Vue 3的响应式差异
- 理解Proxy相比Object.defineProperty的优势

**实践任务：**
```javascript
// 实现一个最简单的响应式对象
const data = { count: 0 }
const reactiveData = makeReactive(data)

// 当数据变化时，自动执行某些操作
effect(() => {
  console.log('count is:', reactiveData.count)
})

reactiveData.count++ // 应该自动打印新值
```

**答案：**

#### 什么是响应式？
响应式编程是一种编程范式，核心思想是**当数据发生变化时，自动触发相关联的更新操作**。在前端框架中，响应式系统能够自动追踪数据依赖关系，当数据变化时自动更新视图或执行相关的副作用函数。

#### 为什么需要响应式？
1. **自动化更新**：无需手动管理数据变化和视图更新的关系
2. **简化开发**：开发者只需关注数据逻辑，框架自动处理UI更新
3. **性能优化**：精确追踪依赖，只更新真正需要更新的部分
4. **代码可维护性**：数据流向清晰，减少手动DOM操作

#### Vue 2 vs Vue 3 响应式对比

**Vue 2 (Object.defineProperty)**：
```javascript
// Vue 2 的局限性
const data = { count: 0 }
Object.defineProperty(data, 'count', {
  get() { /* 依赖收集 */ },
  set(newVal) { /* 触发更新 */ }
})

// 问题：
// 1. 无法检测属性的添加/删除
data.newProp = 'value' // ❌ 不会触发更新
delete data.count // ❌ 不会触发更新

// 2. 数组索引和长度变化检测困难
data.arr[0] = 'new' // ❌ 不会触发更新
data.arr.length = 0 // ❌ 不会触发更新
```

**Vue 3 (Proxy)**：
```javascript
// Vue 3 的优势
const data = new Proxy({ count: 0 }, {
  get(target, key) { /* 依赖收集 */ },
  set(target, key, value) { /* 触发更新 */ },
  deleteProperty(target, key) { /* 删除属性也能检测 */ }
})

// 优势：
// 1. 完整的对象操作拦截
data.newProp = 'value' // ✅ 能够检测
delete data.count // ✅ 能够检测

// 2. 原生数组操作支持
data.arr[0] = 'new' // ✅ 能够检测
data.arr.push('item') // ✅ 能够检测
```

#### Proxy 相比 Object.defineProperty 的核心优势
1. **拦截范围更广**：13种操作 vs 2种操作
2. **性能更好**：不需要递归遍历所有属性
3. **原生数组支持**：无需特殊处理数组方法
4. **动态属性支持**：新增/删除属性自动响应式
5. **更好的类型支持**：支持 Map、Set 等数据结构

![alt text](assets/image.png)

### 问题2：Proxy是如何拦截对象操作的？
**学习重点：**
- Proxy的基本用法和所有拦截器
- get、set、has、deleteProperty等拦截器的作用
- Reflect的作用和为什么要配合使用

**实践任务：**
```javascript
// 实现一个能拦截所有操作的Proxy
const obj = { name: 'Vue', version: 3 }
const proxied = new Proxy(obj, {
  get(target, key, receiver) {
    console.log(`读取属性: ${key}`)
    // 思考：为什么要用Reflect.get而不是target[key]？
    /**
     * this指向问题：
     * 在Proxy的get/set拦截器中，this指向的是原始对象，而不是代理对象。
     * 使用Reflect.get可以确保this指向正确的代理对象
     * 这样可以确保在访问属性时，能够正确地获取到代理对象的
     */
  },
  set(target, key, value, receiver) {
    console.log(`设置属性: ${key} = ${value}`)
    // 思考：如何判断是新增属性还是修改属性？
    // 貌似不需要判断，Proxy会自动处理
    return Reflect.set(target, key, value, receiver)
  }
  // ... 其他拦截器
})
```
**答案：**

#### Proxy 拦截器详解

Proxy 提供了 13 种拦截器，覆盖了对象的所有基本操作：

```javascript
const proxy = new Proxy(target, {
  // 属性访问拦截
  get(target, key, receiver) {
    console.log(`访问属性: ${key}`)
    return Reflect.get(target, key, receiver)
  },
  
  // 属性设置拦截
  set(target, key, value, receiver) {
    console.log(`设置属性: ${key} = ${value}`)
    return Reflect.set(target, key, value, receiver)
  },
  
  // 属性检查拦截
  has(target, key) {
    console.log(`检查属性: ${key}`)
    return Reflect.has(target, key)
  },
  
  // 属性删除拦截
  deleteProperty(target, key) {
    console.log(`删除属性: ${key}`)
    return Reflect.deleteProperty(target, key)
  },
  
  // 其他拦截器：ownKeys, getPrototypeOf, setPrototypeOf 等
})
```

#### 为什么必须配合 Reflect？

**1. 正确的 this 指向**
```javascript
const obj = {
  name: 'Vue',
  getName() {
    return this.name // this 应该指向代理对象，而不是原始对象
  }
}

const proxy = new Proxy(obj, {
  get(target, key, receiver) {
    // ❌ 错误方式：this 指向原始对象
    // return target[key]
    
    // ✅ 正确方式：this 指向代理对象
    return Reflect.get(target, key, receiver)
  }
})
```

**2. 正确的返回值处理**
```javascript
const proxy = new Proxy({}, {
  set(target, key, value, receiver) {
    // Reflect.set 返回 boolean，表示操作是否成功
    const result = Reflect.set(target, key, value, receiver)
    if (result) {
      // 只有设置成功才触发更新
      trigger(target, key)
    }
    return result
  }
})
```

**3. 原型链的正确处理**
```javascript
// 当访问继承属性时，Reflect 确保正确的原型链查找
const parent = { parentProp: 'parent' }
const child = Object.create(parent)
const proxy = new Proxy(child, {
  get(target, key, receiver) {
    // Reflect.get 会正确处理原型链查找
    return Reflect.get(target, key, receiver)
  }
})
```

#### 判断新增 vs 修改属性
```javascript
set(target, key, value, receiver) {
  const hadKey = Object.prototype.hasOwnProperty.call(target, key)
  const oldValue = target[key]
  const result = Reflect.set(target, key, value, receiver)
  
  if (!hadKey) {
    console.log(`新增属性: ${key}`)
    // 触发 ADD 类型的更新
  } else if (value !== oldValue) {
    console.log(`修改属性: ${key}`)
    // 触发 SET 类型的更新
  }
  
  return result
}
```


### 问题3：依赖收集是如何工作的？
**学习重点：**
- 什么是依赖收集？
- effect函数的作用和实现原理
- track函数如何收集dependencies
- 依赖收集的数据结构设计

**实践任务：**
```javascript
// 实现依赖收集系统
let activeEffect = null
const targetMap = new WeakMap()

function effect(fn) {
  activeEffect = fn
  fn() // 执行函数，触发get拦截器，进行依赖收集
  activeEffect = null
}

function track(target, key) {
  // 思考：如何建立target -> key -> effects的映射关系？
  /**
   *  targetMap是一个WeakMap，key是target对象，value是一个Map，
   *  Map的key是属性名，value是一个Set（源码中是dep，内部也是一个Set），存储所有依赖于这个属性的effect函数。
   *  这样可以确保每个target和key的组合只存储一次effect函数，避免重复执行。
   *  WeakMap的优势是可以自动清理不再使用的target对象，避免内存泄漏。
   * /
  // 思考：为什么使用WeakMap而不是Map？
}
```
**答案：**

#### 依赖收集的核心概念

依赖收集是响应式系统的核心机制，它在**数据访问时**自动建立**数据与副作用函数**之间的依赖关系。

#### 数据结构设计

```javascript
// 全局依赖映射：WeakMap<target, Map<key, Set<effect>>>
const targetMap = new WeakMap()

// 结构示意：
// targetMap: {
//   obj1: Map {
//     'name': Set { effect1, effect2 },
//     'age': Set { effect1 }
//   },
//   obj2: Map {
//     'count': Set { effect3 }
//   }
// }
```

#### effect 函数实现原理

```javascript
let activeEffect = null
let effectStack = [] // 解决嵌套 effect 问题

export function effect(fn, options = {}) {
  const effectFn = () => {
    // 1. 清理之前的依赖，避免内存泄漏
    cleanup(effectFn)
    
    try {
      // 2. 处理嵌套 effect
      effectStack.push(activeEffect)
      activeEffect = effectFn
      
      // 3. 执行副作用函数，触发依赖收集
      return fn()
    } finally {
      // 4. 恢复上一个 effect
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }
  
  // 5. 为 effect 添加依赖列表，用于清理
  effectFn.deps = []
  
  // 6. 支持懒执行（computed 需要）
  if (!options.lazy) {
    effectFn()
  }
  
  return effectFn
}
```

#### track 函数实现

```javascript
export function track(target, key) {
  // 1. 没有激活的 effect，无需收集
  if (!activeEffect) return
  
  // 2. 获取或创建 target 对应的依赖 Map
  let deps = targetMap.get(target)
  if (!deps) {
    targetMap.set(target, (deps = new Map()))
  }
  
  // 3. 获取或创建 key 对应的依赖 Set
  let dep = deps.get(key)
  if (!dep) {
    deps.set(key, (dep = new Set()))
  }
  
  // 4. 建立双向连接
  dep.add(activeEffect)           // effect 依赖这个属性
  activeEffect.deps.push(dep)     // 属性被这个 effect 依赖
}
```

#### 为什么使用 WeakMap？

1. **自动垃圾回收**：当 target 对象被销毁时，对应的依赖关系也会被自动清理
2. **避免内存泄漏**：不会因为依赖映射而阻止对象被回收
3. **性能优化**：WeakMap 的查找性能优于普通对象

```javascript
// 示例：对象销毁时自动清理
let obj = { count: 0 }
const reactiveObj = reactive(obj)

effect(() => {
  console.log(reactiveObj.count) // 建立依赖关系
})

// 当 obj 被销毁时，targetMap 中的对应条目也会被自动清理
obj = null
reactiveObj = null // WeakMap 会自动清理相关依赖
```

#### 完整的依赖收集流程

```javascript
// 1. 创建响应式对象
const state = reactive({ count: 0 })

// 2. 创建副作用函数
effect(() => {
  console.log('count:', state.count) // 触发 get 拦截器
})

// 流程：
// effect() → 设置 activeEffect → 执行 fn() → 访问 state.count 
// → 触发 get 拦截器 → 调用 track(state, 'count') 
// → 建立依赖关系 → 完成收集
```


### 问题4：派发更新是如何触发的？
**学习重点：**
- trigger函数的实现原理
- 数组操作的特殊处理

**实践任务：**
```javascript
function trigger(target, key, type) {
  // 思考：如何找到需要执行的effects？
  /**
   *  targetMap存储了所有响应式对象的依赖关系，
   * /
  // 思考：数组的length变化如何处理？
  /**
   * 判断属性是否是Array，记录原来数组的长度，修改后判断长度是否变化，如果变化手动添加一个length属性的更新
   * 这样可以确保数组的length变化时，能够正确触发依赖收
   * /
  // 思考：如何避免重复执行同一个effect？
  /**
   * 使用Set的数据结构来存储effects，确保每个effect只执行一次。
   * 这样可以避免在同一个trigger调用中重复执行同一个effect。
   */
}

// 测试用例
const arr = reactive([1, 2, 3])
effect(() => {
  console.log('数组长度:', arr.length)
})
arr.push(4) // 应该触发effect
```
**答案：**

#### trigger 函数实现原理

```javascript
export function trigger(target, key) {
  // 1. 获取 target 对应的所有依赖
  const deps = targetMap.get(target)
  if (!deps) return
  
  // 2. 获取 key 对应的依赖集合
  const dep = deps.get(key)
  if (!dep) return
  
  // 3. 创建副本避免无限循环
  // 因为 effect 执行时可能会修改 dep 集合
  const effectsToRun = new Set(dep)
  
  // 4. 执行所有相关的副作用函数
  effectsToRun.forEach((effectFn) => {
    if (effectFn.scheduler) {
      // 如果有调度器，使用调度器执行
      effectFn.scheduler(effectFn)
    } else {
      // 否则直接执行
      effectFn()
    }
  })
}
```

#### 数组操作的特殊处理

在我们的实现中，数组操作通过以下方式处理：

```javascript
// reactive.js 中的 set 拦截器
set(target, key, value, receiver) {
  const oldValue = target[key]
  let oldLength
  
  // 记录数组原始长度
  if (isArray(target)) {
    oldLength = target.length
  }
  
  // 执行设置操作
  const result = Reflect.set(target, key, value, receiver)
  
  // 值发生变化才触发更新
  if (hasChanged(value, oldValue)) {
    trigger(target, key)
    
    // 数组长度变化的特殊处理
    if (isArray(target) && target.length !== oldLength) {
      trigger(target, 'length') // 额外触发 length 依赖
    }
  }
  
  return result
}
```

#### 数组操作示例

```javascript
const arr = reactive([1, 2, 3])

// 监听数组长度
effect(() => {
  console.log('数组长度:', arr.length)
})

// 监听特定索引
effect(() => {
  console.log('第一个元素:', arr[0])
})

// 各种数组操作的触发情况：
arr.push(4)      // 触发: length 和新索引的依赖
arr[0] = 'new'   // 触发: 索引 0 的依赖
arr.length = 2   // 触发: length 和被删除索引的依赖
arr.splice(1, 1) // 触发: 多个索引和 length 的依赖
```

#### 避免重复执行的机制

```javascript
// 使用 Set 数据结构自动去重
const effectsToRun = new Set(dep)

// 即使同一个 effect 被多次添加，Set 也只会保留一个
// 例如：修改对象的多个属性，同一个 effect 只执行一次
const state = reactive({ a: 1, b: 2 })
effect(() => {
  console.log(state.a + state.b) // 依赖 a 和 b
})

// 批量修改时，effect 只执行一次
state.a = 10
state.b = 20
```

#### 调度器的作用

```javascript
// 支持自定义执行时机
effect(() => {
  console.log('立即执行')
}, {
  scheduler: (effect) => {
    // 延迟到下一个微任务执行
    Promise.resolve().then(() => effect())
  }
})

// 或者批量执行
const queue = []
let isFlushing = false

effect(() => {
  console.log('批量执行')
}, {
  scheduler: (effect) => {
    queue.push(effect)
    if (!isFlushing) {
      isFlushing = true
      Promise.resolve().then(() => {
        queue.forEach(fn => fn())
        queue.length = 0
        isFlushing = false
      })
    }
  }
})
```

### 问题5：ref是如何实现的？为什么需要ref？
**学习重点：**
- ref的设计理念和使用场景
- ref和reactive的区别
- .value的实现原理

**实践任务：**
```javascript
// 实现ref
function ref(value) {
  // 思考：为什么基本类型需要包装成对象？
  /**
   * 基本类型（如number、string等）在JavaScript中是不可变的，
   * 需要通过对象包装才能实现响应式。
   * 这样可以确保当基本类型的值变化时，能够触发依赖收集和更新。
   */
  // 思考：如何实现.value的响应式？
  /**
   * ref返回一个对象，这个对象有一个value属性，
   * 当访问.value时，会触发get拦截器，进行依赖收集。
   * 当设置.value时，会触发set拦截器，进行派发更新。
   */
}

const count = ref(0)
effect(() => {
  console.log('count:', count.value)
})
count.value++ // 应该触发effect
```
**答案：**

#### ref 的设计理念

ref 解决了 JavaScript 基本类型无法直接响应式的问题，通过**对象包装**的方式让基本类型也能参与响应式系统。

#### 为什么基本类型需要包装？

```javascript
// 基本类型的问题
let count = 0
effect(() => {
  console.log(count) // 无法建立响应式连接
})
count = 1 // 不会触发 effect 重新执行

// 对象类型可以直接响应式
const state = reactive({ count: 0 })
effect(() => {
  console.log(state.count) // 可以建立响应式连接
})
state.count = 1 // 会触发 effect 重新执行
```

#### ref 的完整实现

```javascript
const IS_REF = Symbol('isRef')

export function ref(value) {
  // 如果已经是 ref，直接返回
  if (isRef(value)) {
    return value
  }
  return new RefImpl(value)
}

class RefImpl {
  constructor(value) {
    // 如果值是对象，转换为响应式对象
    this._value = isObject(value) ? reactive(value) : value
    this[IS_REF] = true // 标记为 ref
  }
  
  get value() {
    // 依赖收集：当访问 .value 时收集依赖
    track(this, 'value')
    return this._value
  }
  
  set value(newValue) {
    // 只有值真正改变时才触发更新
    if (hasChanged(newValue, this._value)) {
      // 如果新值是对象，转换为响应式
      this._value = isObject(newValue) ? reactive(newValue) : newValue
      // 触发依赖更新
      trigger(this, 'value')
    }
  }
}

export function isRef(value) {
  return !!(value && value[IS_REF])
}
```

#### ref vs reactive 的区别

| 特性 | ref | reactive |
|------|-----|----------|
| **适用类型** | 基本类型 + 对象 | 仅对象类型 |
| **访问方式** | `.value` | 直接访问属性 |
| **模板中** | 自动解包 | 直接使用 |
| **响应式原理** | 对象包装 + getter/setter | Proxy 拦截 |
| **嵌套对象** | 自动转 reactive | 原生支持 |

```javascript
// ref 示例
const count = ref(0)
const user = ref({ name: 'Vue' })

effect(() => {
  console.log(count.value)      // 需要 .value
  console.log(user.value.name)  // 嵌套对象也需要 .value
})

// reactive 示例
const state = reactive({ 
  count: 0, 
  user: { name: 'Vue' } 
})

effect(() => {
  console.log(state.count)      // 直接访问
  console.log(state.user.name)  // 嵌套对象直接访问
})
```

#### ref 的自动解包机制

在 reactive 对象中，ref 会自动解包：

```javascript
// reactive.js 中的处理
get(target, key, receiver) {
  track(target, key)
  const res = Reflect.get(target, key, receiver)
  
  // 如果是 ref，自动返回其 value
  if (isRef(res)) {
    return res.value
  }
  
  return isObject(res) ? reactive(res) : res
}

set(target, key, value, receiver) {
  // 如果目标属性是 ref，直接设置其 value
  if (isRef(target[key])) {
    target[key].value = value
    return true
  }
  
  // 正常设置流程...
}
```

#### 使用场景对比

```javascript
// 1. 基本类型响应式
const count = ref(0)
const message = ref('Hello')

// 2. 单一对象响应式
const user = ref({ name: 'Vue', age: 3 })

// 3. 复杂对象响应式（推荐用 reactive）
const state = reactive({
  count: 0,
  user: { name: 'Vue' },
  list: [1, 2, 3]
})

// 4. 组合使用
const state2 = reactive({
  count: ref(0),        // 在 reactive 中使用 ref
  user: { name: 'Vue' }
})

// 访问时自动解包
console.log(state2.count) // 0，不需要 .value
```


### 问题6：computed是如何实现懒计算和缓存的？
**学习重点：**
- computed的缓存机制
- 懒计算的实现原理
- computed和effect的关系

**实践任务：**
```javascript
// 实现computed
function computed(getter) {
  // 思考：如何实现缓存？
  /**
   * computed()执行会返回一个对象，对象有一个属性是dirty
   * dirty表示是否需要重新计算
   * 如果dirty为true，则需要重新计算，否则返回缓存的值
   * 如果没有依赖变化dirty则为false，不需要重新计算
   */
  // 思考：何时重新计算？
  /**
   * computed的依赖项发生改变时
   */
  // 思考：computed本身也是响应式的，如何实现？
  /**
   * computed在get的时候也会收集依赖，当computed的依赖项变化时，
   * 会触发scheduler通知依赖于computed的effect重新执行
   * 这些effect调用时就会访问到computed的值从而重新计算
   */
}

const state = reactive({ firstName: 'John', lastName: 'Doe' })
const fullName = computed(() => {
  console.log('计算fullName') // 应该只在依赖变化时执行
  return `${state.firstName} ${state.lastName}`
})
```
**答案：**

#### computed 的完整实现

```javascript
export function computed(getterOrOptions) {
  let getter, setter
  
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions
    setter = () => {
      console.warn('Computed property is readonly')
    }
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }
  
  return new ComputedRefImpl(getter, setter)
}

class ComputedRefImpl {
  constructor(getter, setter) {
    this._setter = setter
    this._dirty = true    // 脏标记：是否需要重新计算
    this._value = undefined // 缓存的计算结果
    
    // 创建内部 effect，设置为懒执行
    this.effect = effect(getter, {
      lazy: true,  // 懒执行：不立即执行
      scheduler: () => {
        // 依赖变化时的调度器
        if (!this._dirty) {
          this._dirty = true
          // 通知依赖当前 computed 的 effect
          trigger(this, 'value')
        }
      }
    })
  }
  
  get value() {
    // 1. 依赖收集：收集依赖当前 computed 的 effect
    track(this, 'value')
    
    // 2. 懒计算：只有脏了才重新计算
    if (this._dirty) {
      this._value = this.effect() // 执行 getter
      this._dirty = false         // 重置脏标记
    }
    
    // 3. 返回缓存值
    return this._value
  }
  
  set value(newValue) {
    this._setter(newValue)
  }
}
```

#### 缓存机制详解

**1. 脏标记（dirty flag）**
```javascript
// 初始状态：_dirty = true，需要计算
const fullName = computed(() => {
  console.log('计算执行') // 只在需要时打印
  return `${firstName.value} ${lastName.value}`
})

// 第一次访问：_dirty = true → 执行计算 → _dirty = false
console.log(fullName.value) // "计算执行" + "John Doe"

// 第二次访问：_dirty = false → 直接返回缓存
console.log(fullName.value) // 直接返回 "John Doe"，不打印"计算执行"

// 依赖变化：firstName 改变 → scheduler 执行 → _dirty = true
firstName.value = 'Jane'

// 再次访问：_dirty = true → 重新计算 → _dirty = false
console.log(fullName.value) // "计算执行" + "Jane Doe"
```

#### 懒计算实现原理

**1. lazy effect**
```javascript
// 普通 effect：立即执行
effect(() => {
  console.log('立即执行')
}) // 马上打印 "立即执行"

// 懒 effect：不立即执行
const lazyEffect = effect(() => {
  console.log('懒执行')
}, { lazy: true })

// 手动执行才会运行
lazyEffect() // 现在才打印 "懒执行"
```

**2. computed 的懒特性**
```javascript
// 创建 computed 时不会执行 getter
const expensiveComputed = computed(() => {
  console.log('昂贵的计算') // 创建时不会打印
  return heavyCalculation()
})

// 只有访问时才执行
console.log(expensiveComputed.value) // 现在才打印并计算
```

#### computed 与 effect 的关系

**1. computed 内部使用 effect**
```javascript
// computed 本质上是一个特殊的 effect
const computed = (getter) => {
  const effectFn = effect(getter, { lazy: true })
  return {
    get value() {
      return effectFn() // 执行 effect 获取最新值
    }
  }
}
```

**2. 双重身份**
```javascript
const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed(() => {
  return `${firstName.value} ${lastName.value}`
})

// fullName 既是 effect（依赖 firstName 和 lastName）
// 也是响应式数据（可以被其他 effect 依赖）
effect(() => {
  console.log('Full name is:', fullName.value)
})
```

#### 完整的执行流程

```javascript
// 1. 创建阶段
const count = ref(0)
const doubled = computed(() => count.value * 2)

// 2. 首次访问
effect(() => {
  console.log(doubled.value) // 触发计算链
})

// 流程：
// effect 执行 → 访问 doubled.value → track(doubled, 'value')
// → doubled._dirty = true → 执行 doubled.effect()
// → 访问 count.value → track(count, 'value')
// → 返回计算结果 → doubled._dirty = false

// 3. 依赖更新
count.value = 1

// 流程：
// count 变化 → trigger(count, 'value') → doubled.scheduler 执行
// → doubled._dirty = true → trigger(doubled, 'value')
// → 依赖 doubled 的 effect 重新执行 → 访问 doubled.value
// → 重新计算 → 返回新结果
```

#### 性能优化要点

**1. 避免不必要的计算**
```javascript
// ✅ 好的做法：computed 会缓存结果
const expensiveValue = computed(() => {
  return items.value.filter(item => item.active)
                   .map(item => heavyTransform(item))
})

// ❌ 不好的做法：每次都重新计算
const getExpensiveValue = () => {
  return items.value.filter(item => item.active)
                   .map(item => heavyTransform(item))
}
```

**2. 合理的依赖粒度**
```javascript
// ✅ 细粒度依赖：只有相关字段变化才重新计算
const fullName = computed(() => {
  return `${user.value.firstName} ${user.value.lastName}`
})

// ❌ 粗粒度依赖：整个 user 对象变化都会重新计算
const fullName = computed(() => {
  const u = user.value
  return `${u.firstName} ${u.lastName}`
})
```

[computed的执行过程](./流程图/computed-flow-diagram.md)

## 📖 理论学习资源

### Vue 3官方文档
- [响应式基础](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html)
- [深入响应式系统](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)

### 源码对应位置
core/packages/reactivity/src

### 关键概念梳理
1. **响应式对象** - 通过Proxy创建的能够自动追踪变化的对象
2. **副作用函数** - 会产生副作用的函数，需要在数据变化时重新执行
3. **依赖收集** - 在副作用函数执行时收集其依赖的响应式数据
4. **派发更新** - 当响应式数据变化时，通知所有依赖它的副作用函数重新执行

## 🛠️ 实践任务清单

- [✅] 实现基础的reactive函数
- [✅] 实现effect函数和依赖收集
- [✅] 实现trigger函数和派发更新
- [✅] 处理数组的响应式
- [✅] 实现ref函数
- [✅] 实现computed函数
- [✅] 处理边界情况（循环依赖、嵌套effect等）
- [✅] 编写测试用例验证实现正确性

## 🔬 源码研读重点

### 1. reactive.ts中的createReactiveObject函数
```typescript
// 思考问题：
// 1. 为什么需要不同的拦截器？
// 2. 如何处理已经是响应式的对象？
// 3. 如何处理不可代理的对象？
```

**答案：**

#### 1. 为什么需要不同的拦截器（handlers）？

**答案：** 不同类型的对象有不同的内部结构和操作语义，需要专门的处理策略：

```javascript
// 普通对象处理器
const baseHandlers = {
  get(target, key, receiver) {
    // 处理普通属性访问
    const res = Reflect.get(target, key, receiver)
    track(target, key)
    return isObject(res) ? reactive(res) : res
  },
  set(target, key, value, receiver) {
    const oldValue = target[key]
    const result = Reflect.set(target, key, value, receiver)
    if (hasChanged(value, oldValue)) {
      trigger(target, key)
    }
    return result
  }
}

// 数组特殊处理器
const arrayHandlers = {
  ...baseHandlers,
  get(target, key, receiver) {
    // 数组方法的特殊处理
    if (arrayInstrumentations.hasOwnProperty(key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
    return baseHandlers.get(target, key, receiver)
  }
}

// 集合类型处理器（Map、Set、WeakMap、WeakSet）
const collectionHandlers = {
  get(target, key, receiver) {
    // 集合方法需要特殊绑定 this
    if (key === 'size') {
      track(target, 'iterate')
      return Reflect.get(target, key, target)
    }
    return getCollectionMethod(key, target)
  }
}
```

**为什么需要区分？**
1. **数组**：需要特殊处理 `push`、`pop`、`shift`、`unshift`、`splice` 等方法
2. **Map/Set**：需要处理 `size` 属性和迭代器方法
3. **普通对象**：标准的属性访问和设置

#### 2. 如何处理已经是响应式的对象？

**答案：** 通过 `reactiveMap` 缓存机制避免重复代理：

```javascript
// 全局缓存映射
const reactiveMap = new WeakMap()
const readonlyMap = new WeakMap()

export function reactive(target) {
  // 1. 基本类型检查
  if (!isObject(target)) {
    return target
  }
  
  // 2. 检查是否已经是响应式对象
  if (target[ReactiveFlags.IS_REACTIVE]) {
    return target
  }
  
  // 3. 检查缓存
  const existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  
  // 4. 创建新的响应式对象
  const proxy = new Proxy(target, baseHandlers)
  
  // 5. 缓存结果
  reactiveMap.set(target, proxy)
  
  return proxy
}
```

**缓存的好处：**
1. **性能优化**：避免重复创建 Proxy
2. **引用一致性**：同一个对象总是返回同一个代理
3. **内存优化**：使用 WeakMap 自动垃圾回收

```javascript
// 示例：引用一致性
const obj = { count: 0 }
const reactive1 = reactive(obj)
const reactive2 = reactive(obj)

console.log(reactive1 === reactive2) // true，返回同一个代理
```

#### 3. 如何处理不可代理的对象？

**答案：** 通过多层检查确保只有合适的对象才被代理：

```javascript
// 不可代理对象的判断
function canObserve(value) {
  return (
    !value[ReactiveFlags.SKIP] &&           // 没有跳过标记
    isObservableType(toRawType(value)) &&    // 是可观察类型
    !Object.isFrozen(value)                  // 没有被冻结
  )
}

// 可观察类型检查
const isObservableType = makeMap(
  'Object,Array,Map,Set,WeakMap,WeakSet'
)

// 获取对象的原始类型
function toRawType(value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

export function reactive(target) {
  // 基本类型直接返回
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }
    return target
  }
  
  // 不可观察对象直接返回
  if (!canObserve(target)) {
    return target
  }
  
  // 其他处理逻辑...
}
```

**不可代理的情况：**
1. **基本类型**：`string`、`number`、`boolean`、`null`、`undefined`
2. **特殊对象**：`Date`、`RegExp`、`Promise` 等
3. **冻结对象**：`Object.freeze()` 处理过的对象
4. **标记跳过**：带有 `__v_skip` 标记的对象

```javascript
// 示例：各种不可代理情况
reactive(42)                    // 返回 42
reactive('hello')               // 返回 'hello'
reactive(new Date())            // 返回原 Date 对象
reactive(Object.freeze({}))     // 返回原冻结对象

// 手动标记跳过
const skipObj = { __v_skip: true, data: 'test' }
reactive(skipObj)               // 返回原对象
```



### 2. effect.ts中的ReactiveEffect类
```typescript
// 思考问题：
// 1. 为什么需要effect栈？
// 2. 如何处理effect的停止和恢复？
// 3. scheduler的作用是什么？
```

**答案：**

#### 1. effect栈的作用是什么？

**答案：** effect 栈解决了嵌套 effect 执行时的上下文管理问题：

```javascript
let activeEffect = null
const effectStack = []

function effect(fn, options = {}) {
  const effectFn = () => {
    cleanup(effectFn)
    
    try {
      // 入栈：保存当前 activeEffect
      effectStack.push(activeEffect)
      activeEffect = effectFn
      
      // 执行副作用函数
      return fn()
    } finally {
      // 出栈：恢复上一个 activeEffect
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }
  
  effectFn.deps = []
  effectFn()
  return effectFn
}
```

**嵌套 effect 的问题示例：**
```javascript
// 没有栈管理的问题
effect(() => {
  console.log('外层 effect')
  
  effect(() => {
    console.log('内层 effect')
    // 这里 activeEffect 被内层覆盖
  })
  
  // 这里 activeEffect 应该恢复为外层，但没有栈就会丢失
  console.log('外层 effect 继续')
})

// 有栈管理的正确流程
// 1. activeEffect = null, stack = []
// 2. 外层 effect 开始: activeEffect = outerEffect, stack = [null]
// 3. 内层 effect 开始: activeEffect = innerEffect, stack = [null, outerEffect]
// 4. 内层 effect 结束: activeEffect = outerEffect, stack = [null]
// 5. 外层 effect 结束: activeEffect = null, stack = []
```

#### 2. 如何停止和恢复effect？

**答案：** 通过 `stop` 方法和重新执行实现 effect 的生命周期管理：

```javascript
function effect(fn, options = {}) {
  const effectFn = () => {
    // 如果已停止，不执行
    if (!effectFn.active) return
    
    cleanup(effectFn)
    
    try {
      effectStack.push(activeEffect)
      activeEffect = effectFn
      return fn()
    } finally {
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }
  
  effectFn.deps = []
  effectFn.active = true  // 活跃状态标记
  
  // 停止方法
  effectFn.stop = () => {
    if (effectFn.active) {
      cleanup(effectFn)     // 清理所有依赖
      effectFn.active = false
      if (options.onStop) {
        options.onStop()    // 停止回调
      }
    }
  }
  
  if (!options.lazy) {
    effectFn()
  }
  
  return effectFn
}

// cleanup 函数：清理依赖关系
function cleanup(effectFn) {
  const { deps } = effectFn
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effectFn)  // 从依赖集合中移除
    }
    deps.length = 0             // 清空依赖数组
  }
}
```

#### 3. scheduler的作用是什么？

**答案：** scheduler 提供了自定义 effect 执行时机的能力，实现异步更新、批量更新等高级功能：

```javascript
function effect(fn, options = {}) {
  const effectFn = () => {
    // 正常执行逻辑...
  }
  
  effectFn.scheduler = options.scheduler
  
  // 其他逻辑...
}

// trigger 中使用 scheduler
function trigger(target, key) {
  const deps = targetMap.get(target)
  if (!deps) return
  
  const effects = deps.get(key)
  if (!effects) return
  
  const effectsToRun = new Set(effects)
  
  effectsToRun.forEach(effectFn => {
    if (effectFn.scheduler) {
      // 使用自定义调度器
      effectFn.scheduler(effectFn)
    } else {
      // 直接执行
      effectFn()
    }
  })
}
```

**常见的 scheduler 应用：**

**1. 异步更新（微任务）**
```javascript
effect(() => {
  console.log('异步更新:', state.count)
}, {
  scheduler: (effect) => {
    Promise.resolve().then(() => effect())
  }
})

state.count = 1
state.count = 2
state.count = 3
// 只会在微任务中执行一次，输出: "异步更新: 3"
```

**2. 批量更新**
```javascript
const queue = new Set()
let isFlushing = false

function queueJob(job) {
  queue.add(job)
  if (!isFlushing) {
    isFlushing = true
    Promise.resolve().then(() => {
      queue.forEach(job => job())
      queue.clear()
      isFlushing = false
    })
  }
}

effect(() => {
  console.log('批量更新:', state.count)
}, {
  scheduler: queueJob
})

// 同步修改多次，只执行一次更新
state.count = 1
state.count = 2
state.count = 3
// 输出: "批量更新: 3"
```


### 3. baseHandlers.ts中的get和set拦截器
```typescript
// 思考问题：
// 1. 如何处理深层嵌套的对象？
// 2. 如何处理数组的特殊索引？
// 3. 如何避免不必要的依赖收集？
```

**答案：**

#### 1. 如何处理深层嵌套对象？

**答案：** 通过在 `get` 拦截器中递归转换实现深层响应式：

```javascript
const baseHandlers = {
  get(target, key, receiver) {
    // 1. 处理特殊属性
    if (key === ReactiveFlags.IS_REACTIVE) {
      return true
    }
    if (key === ReactiveFlags.RAW) {
      return target
    }
    
    // 2. 依赖收集
    track(target, key)
    
    // 3. 获取原始值
    const res = Reflect.get(target, key, receiver)
    
    // 4. 处理 ref 自动解包
    if (isRef(res)) {
      return res.value
    }
    
    // 5. 深层响应式转换
    if (isObject(res)) {
      return reactive(res)  // 递归转换嵌套对象
    }
    
    return res
  },
  
  set(target, key, value, receiver) {
    const oldValue = target[key]
    
    // 处理 ref 的特殊设置
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value
      return true
    }
    
    const result = Reflect.set(target, key, value, receiver)
    
    // 只有值真正改变时才触发更新
    if (hasChanged(value, oldValue)) {
      trigger(target, key)
    }
    
    return result
  }
}
```

**深层响应式示例：**
```javascript
const state = reactive({
  user: {
    profile: {
      name: 'Vue',
      settings: {
        theme: 'dark'
      }
    }
  }
})

// 访问深层属性时自动转换为响应式
effect(() => {
  // state.user → reactive(user)
  // state.user.profile → reactive(profile)
  // state.user.profile.settings → reactive(settings)
  console.log(state.user.profile.settings.theme)
})

// 深层修改也能触发更新
state.user.profile.settings.theme = 'light'  // 触发 effect
```

#### 2. 如何处理数组的特殊索引？

**答案：** 数组需要特殊处理索引访问、长度变化和数组方法：

```javascript
// 数组方法的特殊处理
const arrayInstrumentations = {}

// 需要特殊处理的数组方法
;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
  const originalMethod = Array.prototype[key]
  arrayInstrumentations[key] = function(...args) {
    // 暂停依赖收集，避免在方法执行过程中收集不必要的依赖
    pauseTracking()
    const result = originalMethod.apply(this, args)
    resetTracking()
    return result
  }
})

const arrayHandlers = {
  get(target, key, receiver) {
    // 1. 处理数组方法
    if (arrayInstrumentations.hasOwnProperty(key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
    
    // 2. 处理数组索引和长度
    if (typeof key === 'string' && /^\d+$/.test(key)) {
      // 数字字符串索引
      track(target, key)
    } else if (key === 'length') {
      // 长度属性
      track(target, 'length')
    }
    
    return baseHandlers.get(target, key, receiver)
  },
  
  set(target, key, value, receiver) {
    const oldValue = target[key]
    const oldLength = target.length
    
    const result = Reflect.set(target, key, value, receiver)
    
    // 处理数组长度变化
    if (key === 'length' && value < oldLength) {
      // 数组被截断，触发被删除元素的依赖
      for (let i = value; i < oldLength; i++) {
        trigger(target, String(i))
      }
    } else if (typeof key === 'string' && /^\d+$/.test(key)) {
      // 数组索引变化
      const index = Number(key)
      if (index >= oldLength) {
        // 新增元素，触发 length 依赖
        trigger(target, 'length')
      }
    }
    
    if (hasChanged(value, oldValue)) {
      trigger(target, key)
    }
    
    return result
  }
}
```

#### 3. 如何避免不必要的依赖收集？

**答案：** 通过多种策略过滤不需要追踪的属性访问：

```javascript
// 不需要追踪的 key 类型
const isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`)

// Symbol 类型的内置 key
const builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(isSymbol)
)

function get(target, key, receiver) {
  // 1. 跳过特殊属性
  if (key === ReactiveFlags.IS_REACTIVE) {
    return true
  }
  if (key === ReactiveFlags.RAW) {
    return target
  }
  
  // 2. 跳过不可追踪的 key
  if (isNonTrackableKeys(key)) {
    return Reflect.get(target, key, receiver)
  }
  
  // 3. 跳过内置 Symbol
  if (isSymbol(key) && builtInSymbols.has(key)) {
    return Reflect.get(target, key, receiver)
  }
  
  const res = Reflect.get(target, key, receiver)
  
  // 4. 只有在有 activeEffect 时才收集依赖
  if (activeEffect) {
    track(target, key)
  }
  
  return isObject(res) ? reactive(res) : res
}

// 追踪控制
let shouldTrack = true
const trackStack = []

export function pauseTracking() {
  trackStack.push(shouldTrack)
  shouldTrack = false
}

export function resetTracking() {
  const last = trackStack.pop()
  shouldTrack = last === undefined ? true : last
}

function track(target, key) {
  // 只有在允许追踪且有活跃 effect 时才收集依赖
  if (!shouldTrack || !activeEffect) {
    return
  }
  
  // 依赖收集逻辑...
}
```

## ✅ 学习成果检验

完成本阶段学习后，您应该能够：

1. **理论理解**
   - [ ] 清楚解释什么是响应式以及Vue 3响应式的优势
   - [ ] 理解Proxy相比Object.defineProperty的优势
   - [ ] 掌握依赖收集和派发更新的完整流程

2. **实践能力**
   - [ ] 独立实现一个基础的响应式系统
   - [ ] 处理各种边界情况和异常场景
   - [ ] 编写完整的测试用例

3. **源码理解**
   - [ ] 能够阅读Vue 3响应式相关源码
   - [ ] 理解源码中的设计思路和实现细节
   - [ ] 能够解释源码中的关键函数作用

## 🎯 进阶思考题

1. 为什么Vue 3选择Proxy而不是继续使用Object.defineProperty？
2. 依赖收集的数据结构为什么设计成target -> key -> effects的映射？
3. effect嵌套时如何正确收集依赖？
4. 如何处理Set、Map等集合类型的响应式？
5. computed的懒计算是如何实现的？什么时候会重新计算？


# Vue3 Computed 运行流程图

## 1. 创建阶段 (Creation Phase)

```
┌─────────────────────────────────────┐
│        computed(getter)             │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│    new ComputedRefImpl(getter)      │
│  ┌─────────────────────────────────┐│
│  │ this._dirty = true              ││
│  │ this._value = undefined         ││
│  │ this._setter = setter           ││
│  └─────────────────────────────────┘│
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│     effect(getter, {                │
│       lazy: true,                   │
│       scheduler: () => {...}        │
│     })                              │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│   返回 ComputedRefImpl 实例         │
│   (此时还未执行计算)                │
└─────────────────────────────────────┘
```

## 2. 首次访问阶段 (First Access)

```
┌─────────────────────────────────────┐
│        computed.value               │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│      track(this, 'value')           │
│   (建立当前effect与computed的依赖)  │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│      if (this._dirty) ?             │
└─────────┬─────────────────┬─────────┘
          │ true            │ false
          ▼                 ▼
┌─────────────────┐    ┌──────────────┐
│ 执行计算         │    │ 返回缓存值    │
└─────────┬───────┘    └──────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│    this._value = this.effect()      │
│    (执行 getter 函数)               │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│    this._dirty = false              │
│    (标记为非脏状态)                 │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│       return this._value            │
└─────────────────────────────────────┘
```

## 3. 依赖变化阶段 (Dependency Change)

```
┌─────────────────────────────────────┐
│     依赖的响应式数据变化             │
│    (如 ref.value = newValue)        │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│   触发依赖的 trigger()              │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│   找到依赖该数据的所有 effect       │
│   (包括 computed 的 effect)         │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│   调用 computed 的 scheduler        │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│      if (!this._dirty) ?            │
└─────────┬─────────────────┬─────────┘
          │ true            │ false
          ▼                 ▼
┌─────────────────┐    ┌──────────────┐
│ 标记为脏状态     │    │ 不执行任何操作│
└─────────┬───────┘    └──────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│     this._dirty = true              │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│     trigger(this, 'value')          │
│   (通知依赖当前computed的effect)    │
└─────────────────────────────────────┘
```

## 4. 再次访问阶段 (Subsequent Access)

```
┌─────────────────────────────────────┐
│        computed.value               │
│      (依赖变化后的访问)             │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│      track(this, 'value')           │
│   (重新建立依赖关系)                │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│      if (this._dirty) ?             │
└─────────┬─────────────────┬─────────┘
          │ true            │ false
          ▼                 ▼
┌─────────────────┐    ┌──────────────┐
│ 重新计算         │    │ 返回缓存值    │
└─────────┬───────┘    └──────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│    this._value = this.effect()      │
│    (重新执行 getter)                │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│    this._dirty = false              │
└─────────────────┬───────────────────┘
                  │
                  ▼
┌─────────────────────────────────────┐
│       return this._value            │
└─────────────────────────────────────┘
```

## 5. 完整生命周期示例

```
时间线:
  │
  ▼ T1: 创建 computed
┌─────────────────────────────────────┐
│ const c = computed(() => a.value + 1)│
│ _dirty: true, _value: undefined     │
└─────────────────────────────────────┘
  │
  ▼ T2: 首次访问
┌─────────────────────────────────────┐
│ console.log(c.value) // 2           │
│ _dirty: false, _value: 2            │
│ 建立 a -> c 的依赖关系              │
└─────────────────────────────────────┘
  │
  ▼ T3: 再次访问（使用缓存）
┌─────────────────────────────────────┐
│ console.log(c.value) // 2           │
│ _dirty: false, _value: 2 (缓存)     │
└─────────────────────────────────────┘
  │
  ▼ T4: 依赖变化
┌─────────────────────────────────────┐
│ a.value = 5                         │
│ 触发 c 的 scheduler                 │
│ _dirty: true, _value: 2 (旧值)      │
└─────────────────────────────────────┘
  │
  ▼ T5: 变化后访问
┌─────────────────────────────────────┐
│ console.log(c.value) // 6           │
│ _dirty: false, _value: 6 (新值)     │
└─────────────────────────────────────┘
```

## 6. 关键机制说明

### 懒执行 (Lazy Execution)
```
effect(getter, { lazy: true })
   ↓
创建时不执行，只有访问 .value 时才执行
```

### 脏标记 (Dirty Flag)
```
_dirty: true  → 需要重新计算
_dirty: false → 可以使用缓存值
```

### 调度器 (Scheduler)
```
scheduler: () => {
  if (!this._dirty) {
    this._dirty = true;
    trigger(this, 'value');
  }
}
```

### 依赖收集 (Dependency Tracking)
```
track(this, 'value') → 每次访问都收集依赖
trigger(this, 'value') → 通知依赖此 computed 的 effect
```

这个流程图展示了 computed 如何实现**懒计算**、**缓存**和**响应式更新**的核心机制！
